// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: telemetry.proto
#ifndef GRPC_telemetry_2eproto__INCLUDED
#define GRPC_telemetry_2eproto__INCLUDED

#include "telemetry.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// GRPC service definition
class TelemetryManager final {
 public:
  static constexpr char const* service_full_name() {
    return "TelemetryManager";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // POS -> TelemetryManager
    virtual ::grpc::Status configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::ConfigureMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>> Asyncconfigure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>>(AsyncconfigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>> PrepareAsyncconfigure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>>(PrepareAsyncconfigureRaw(context, request, cq));
    }
    // POS -> TelemetryManager
    virtual ::grpc::Status publish(::grpc::ClientContext* context, const ::PublishRequest& request, ::PublishResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>> Asyncpublish(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>>(AsyncpublishRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>> PrepareAsyncpublish(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>>(PrepareAsyncpublishRaw(context, request, cq));
    }
    // Collector -> TelemetryManager
    virtual ::grpc::Status collect(::grpc::ClientContext* context, const ::CollectRequest& request, ::CollectResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>> Asynccollect(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>>(AsynccollectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>> PrepareAsynccollect(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>>(PrepareAsynccollectRaw(context, request, cq));
    }
    // CLI -> TelemetryManager
    virtual ::grpc::Status enable(::grpc::ClientContext* context, const ::EnableRequest& request, ::EnableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>> Asyncenable(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>>(AsyncenableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>> PrepareAsyncenable(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>>(PrepareAsyncenableRaw(context, request, cq));
    }
    // CLI -> TelemetryManager
    virtual ::grpc::Status disable(::grpc::ClientContext* context, const ::DisableRequest& request, ::DisableResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>> Asyncdisable(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>>(AsyncdisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>> PrepareAsyncdisable(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>>(PrepareAsyncdisableRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // POS -> TelemetryManager
      virtual void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // POS -> TelemetryManager
      virtual void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // Collector -> TelemetryManager
      virtual void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // CLI -> TelemetryManager
      virtual void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // CLI -> TelemetryManager
      virtual void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>* AsyncconfigureRaw(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::ConfigureMetadataResponse>* PrepareAsyncconfigureRaw(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>* AsyncpublishRaw(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PublishResponse>* PrepareAsyncpublishRaw(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>* AsynccollectRaw(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CollectResponse>* PrepareAsynccollectRaw(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>* AsyncenableRaw(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::EnableResponse>* PrepareAsyncenableRaw(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>* AsyncdisableRaw(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::DisableResponse>* PrepareAsyncdisableRaw(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::ConfigureMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>> Asyncconfigure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>>(AsyncconfigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>> PrepareAsyncconfigure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>>(PrepareAsyncconfigureRaw(context, request, cq));
    }
    ::grpc::Status publish(::grpc::ClientContext* context, const ::PublishRequest& request, ::PublishResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PublishResponse>> Asyncpublish(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PublishResponse>>(AsyncpublishRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PublishResponse>> PrepareAsyncpublish(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PublishResponse>>(PrepareAsyncpublishRaw(context, request, cq));
    }
    ::grpc::Status collect(::grpc::ClientContext* context, const ::CollectRequest& request, ::CollectResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CollectResponse>> Asynccollect(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CollectResponse>>(AsynccollectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CollectResponse>> PrepareAsynccollect(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CollectResponse>>(PrepareAsynccollectRaw(context, request, cq));
    }
    ::grpc::Status enable(::grpc::ClientContext* context, const ::EnableRequest& request, ::EnableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EnableResponse>> Asyncenable(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EnableResponse>>(AsyncenableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EnableResponse>> PrepareAsyncenable(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EnableResponse>>(PrepareAsyncenableRaw(context, request, cq));
    }
    ::grpc::Status disable(::grpc::ClientContext* context, const ::DisableRequest& request, ::DisableResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DisableResponse>> Asyncdisable(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DisableResponse>>(AsyncdisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DisableResponse>> PrepareAsyncdisable(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::DisableResponse>>(PrepareAsyncdisableRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void configure(::grpc::ClientContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void publish(::grpc::ClientContext* context, const ::PublishRequest* request, ::PublishResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void collect(::grpc::ClientContext* context, const ::CollectRequest* request, ::CollectResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void enable(::grpc::ClientContext* context, const ::EnableRequest* request, ::EnableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void disable(::grpc::ClientContext* context, const ::DisableRequest* request, ::DisableResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>* AsyncconfigureRaw(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::ConfigureMetadataResponse>* PrepareAsyncconfigureRaw(::grpc::ClientContext* context, const ::ConfigureMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PublishResponse>* AsyncpublishRaw(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PublishResponse>* PrepareAsyncpublishRaw(::grpc::ClientContext* context, const ::PublishRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CollectResponse>* AsynccollectRaw(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CollectResponse>* PrepareAsynccollectRaw(::grpc::ClientContext* context, const ::CollectRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::EnableResponse>* AsyncenableRaw(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::EnableResponse>* PrepareAsyncenableRaw(::grpc::ClientContext* context, const ::EnableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DisableResponse>* AsyncdisableRaw(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::DisableResponse>* PrepareAsyncdisableRaw(::grpc::ClientContext* context, const ::DisableRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_configure_;
    const ::grpc::internal::RpcMethod rpcmethod_publish_;
    const ::grpc::internal::RpcMethod rpcmethod_collect_;
    const ::grpc::internal::RpcMethod rpcmethod_enable_;
    const ::grpc::internal::RpcMethod rpcmethod_disable_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // POS -> TelemetryManager
    virtual ::grpc::Status configure(::grpc::ServerContext* context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response);
    // POS -> TelemetryManager
    virtual ::grpc::Status publish(::grpc::ServerContext* context, const ::PublishRequest* request, ::PublishResponse* response);
    // Collector -> TelemetryManager
    virtual ::grpc::Status collect(::grpc::ServerContext* context, const ::CollectRequest* request, ::CollectResponse* response);
    // CLI -> TelemetryManager
    virtual ::grpc::Status enable(::grpc::ServerContext* context, const ::EnableRequest* request, ::EnableResponse* response);
    // CLI -> TelemetryManager
    virtual ::grpc::Status disable(::grpc::ServerContext* context, const ::DisableRequest* request, ::DisableResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_configure() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfigure(::grpc::ServerContext* context, ::ConfigureMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::ConfigureMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_publish() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpublish(::grpc::ServerContext* context, ::PublishRequest* request, ::grpc::ServerAsyncResponseWriter< ::PublishResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_collect() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcollect(::grpc::ServerContext* context, ::CollectRequest* request, ::grpc::ServerAsyncResponseWriter< ::CollectResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_enable() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestenable(::grpc::ServerContext* context, ::EnableRequest* request, ::grpc::ServerAsyncResponseWriter< ::EnableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_disable() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisable(::grpc::ServerContext* context, ::DisableRequest* request, ::grpc::ServerAsyncResponseWriter< ::DisableResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_configure<WithAsyncMethod_publish<WithAsyncMethod_collect<WithAsyncMethod_enable<WithAsyncMethod_disable<Service > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_configure() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ConfigureMetadataRequest, ::ConfigureMetadataResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::ConfigureMetadataRequest* request, ::ConfigureMetadataResponse* response) { return this->configure(context, request, response); }));}
    void SetMessageAllocatorFor_configure(
        ::grpc::experimental::MessageAllocator< ::ConfigureMetadataRequest, ::ConfigureMetadataResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ConfigureMetadataRequest, ::ConfigureMetadataResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* configure(
      ::grpc::CallbackServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* configure(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_publish() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::PublishRequest, ::PublishResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::PublishRequest* request, ::PublishResponse* response) { return this->publish(context, request, response); }));}
    void SetMessageAllocatorFor_publish(
        ::grpc::experimental::MessageAllocator< ::PublishRequest, ::PublishResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::PublishRequest, ::PublishResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* publish(
      ::grpc::CallbackServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* publish(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_collect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::CollectRequest, ::CollectResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::CollectRequest* request, ::CollectResponse* response) { return this->collect(context, request, response); }));}
    void SetMessageAllocatorFor_collect(
        ::grpc::experimental::MessageAllocator< ::CollectRequest, ::CollectResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CollectRequest, ::CollectResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* collect(
      ::grpc::CallbackServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* collect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_enable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::EnableRequest, ::EnableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::EnableRequest* request, ::EnableResponse* response) { return this->enable(context, request, response); }));}
    void SetMessageAllocatorFor_enable(
        ::grpc::experimental::MessageAllocator< ::EnableRequest, ::EnableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::EnableRequest, ::EnableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* enable(
      ::grpc::CallbackServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* enable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_disable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::DisableRequest, ::DisableResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::DisableRequest* request, ::DisableResponse* response) { return this->disable(context, request, response); }));}
    void SetMessageAllocatorFor_disable(
        ::grpc::experimental::MessageAllocator< ::DisableRequest, ::DisableResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::DisableRequest, ::DisableResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* disable(
      ::grpc::CallbackServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* disable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_configure<ExperimentalWithCallbackMethod_publish<ExperimentalWithCallbackMethod_collect<ExperimentalWithCallbackMethod_enable<ExperimentalWithCallbackMethod_disable<Service > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_configure<ExperimentalWithCallbackMethod_publish<ExperimentalWithCallbackMethod_collect<ExperimentalWithCallbackMethod_enable<ExperimentalWithCallbackMethod_disable<Service > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_configure() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_publish() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_collect() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_enable() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_disable() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_configure() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfigure(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_publish() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestpublish(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_collect() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestcollect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_enable() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestenable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_disable() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdisable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_configure() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->configure(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* configure(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* configure(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_publish() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->publish(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* publish(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* publish(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_collect() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->collect(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* collect(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* collect(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_enable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->enable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* enable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* enable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_disable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->disable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* disable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* disable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_configure() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ConfigureMetadataRequest, ::ConfigureMetadataResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ConfigureMetadataRequest, ::ConfigureMetadataResponse>* streamer) {
                       return this->Streamedconfigure(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::ConfigureMetadataRequest* /*request*/, ::ConfigureMetadataResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedconfigure(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ConfigureMetadataRequest,::ConfigureMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_publish : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_publish() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::PublishRequest, ::PublishResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::PublishRequest, ::PublishResponse>* streamer) {
                       return this->Streamedpublish(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_publish() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status publish(::grpc::ServerContext* /*context*/, const ::PublishRequest* /*request*/, ::PublishResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedpublish(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::PublishRequest,::PublishResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_collect : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_collect() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CollectRequest, ::CollectResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CollectRequest, ::CollectResponse>* streamer) {
                       return this->Streamedcollect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_collect() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status collect(::grpc::ServerContext* /*context*/, const ::CollectRequest* /*request*/, ::CollectResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedcollect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CollectRequest,::CollectResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_enable() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::EnableRequest, ::EnableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::EnableRequest, ::EnableResponse>* streamer) {
                       return this->Streamedenable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status enable(::grpc::ServerContext* /*context*/, const ::EnableRequest* /*request*/, ::EnableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedenable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::EnableRequest,::EnableResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_disable() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::DisableRequest, ::DisableResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::DisableRequest, ::DisableResponse>* streamer) {
                       return this->Streameddisable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status disable(::grpc::ServerContext* /*context*/, const ::DisableRequest* /*request*/, ::DisableResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddisable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::DisableRequest,::DisableResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_configure<WithStreamedUnaryMethod_publish<WithStreamedUnaryMethod_collect<WithStreamedUnaryMethod_enable<WithStreamedUnaryMethod_disable<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_configure<WithStreamedUnaryMethod_publish<WithStreamedUnaryMethod_collect<WithStreamedUnaryMethod_enable<WithStreamedUnaryMethod_disable<Service > > > > > StreamedService;
};


#endif  // GRPC_telemetry_2eproto__INCLUDED
